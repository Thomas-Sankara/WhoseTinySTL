# WhoseTinySTL
环境：gcc version 9.3.0 (Ubuntu 9.3.0-17ubuntu1~20.04) <br>

主要参考对象是《STL源码剖析》第一版和https://github.com/zouxiaohang/TinySTL <br>
次要参考对象是大量网络博客以及https://github.com/karottc/sgi-stl <br>
为了尊重侯捷老师的习惯，我把非实现部分的练习代码都放入以jj开头的文件夹中😀 <br>
大部分内容就是原封不动地照着参考对象撸了一遍，并在注释中补充了大量个人浅见和查阅资料 <br>
下文中以及代码的注释中，”项目作者“指的就是[TinySTL的作者](https://github.com/zouxiaohang) ，“书”指的就是《STL源码剖析》 <br>
主要参考对象可以通过关键字“项目作者”和“书”查到引用出处，其余注释中，大段文字如果也是引用的话，一般会给出出处链接，简短的注释如果是查阅的话我也不给出处了，请见谅。 <br>

## 具体说明
1.如书中55页所说，这里的alloc实现版本不考虑多线程的情况 <br>
2.alloc的实现是没有内存不足时的异常处理机制的，“内存不足”指的是整个系统的内存完全耗尽了 <br>
3.iterator中，书101页上说列出的iterator代码来自SGI的<stl_iterator.h>，但我是在SGI的<stl_iterator_base.h>中找到的。但两者较为一致的是distance和advance系列函数的实现都写在了这个文件里。然而项目作者把这两个系列的函数都写进了<Algorithm.h>里。从书中100页的总结来看，应当写到algorithm或具体的容器里，因为操作iterator的是算法或容器，不是它自己。但是如果这样，那容器本来该和算法分离的，现在却由于这种写法不得不引用algorithm。两种说法我觉得都有道理，但为了先写出能运行的代码，我决定效仿项目作者，把这两个系列函数写进algorithm里。完成完整项目后再考虑更新。 <br>
4.UinitializedFunctions.h里一共有三组函数模板，每组函数都是一个调用两个重载的函数模板。项目作者把每个重载的函数模板声明都在该文件里写了一遍。鉴于每个模板和它的声明的间隔都只有10行左右，且该文件只有这三组函数而没有别的内容，私以为实在没必要将声明和定义分开，于是自己书写时就把每组里的两个重载函数模板的声明和定义写在了一起。侯捷老师提供的样例也是这样做的，见书70页。 <br>
5.关于移动操作有件事要提。当你使用了移动操作，指向被移动对象（尤其是用了std::move的非临时对象)的指针很有可能就不好使了。下面以vector为例：使用STL的时候如果遇到这个问题的话，就会在没有报错的情况下自动终止程序；使用我的WhoseTinySTL的话，就会报“段错误：核心已转储”。千万要避免用std::move把被指针指向的对象变为右值的用法！ <br>
6.项目作者vector的构造函数和insert函数有个技巧，作者写了注释“处理指针和数字间的区别的函数”，但我觉得说明一下比较好。就是对于vec(n,val)这种调用构造函数或vec.insert(n,val)这种调用insert的形式在两个输入都是相同类型的integer时（比如int，unsigned int等等），本来应该调用把val复制n份的那个重载，但是实际上却会调用vec.f(first,last)这种重载形式。因为first和last这种重载形式是模板，而上面那种是普通的函数。当传了两个integer进来时，我们希望调用的vec.f(n,val)由于第一个参数n的类型是size_t，也就是unsigned long long，integer需要型转，而调用模板的话，直接生成两个integer，没有型转，结果就错误调用了另一个函数重载。但没有问题，作者专门写了辅助函数（就是函数名里有_aux的）来处理这问题。通过判断传进来的对象的类型是不是integer来进行辅助函数重载即可。 <br>
7.原作者对list里的const_iterator的处理问题非常大。相应地，listIterator的设计也是有问题的，我都写注释里了，问题非常多。而由问题引发的问题倒也让我多学了不少知识，虽然暂时用不上，比如std::add_const<T>()这种东西。 <br>
8.list中的push、pop与insert、erase的关系可以用两种，可以是前者引用后者，也可以是后者引用前者。项目作者是用后者引用前者，我仿照书中写法用前者引用后者。因为后者引用前者，前者就要单独实现，一共四个push和pop函数，指针操作重复很多。所以我选择用前者引用后者，这是书中的写法。不过要小心，书中没有讨论空列表insert和把列表erase空这两个情况，也没有讨论insert和erase的对象恰好是首元素的情况。这部分代码我都补上了，更详细的解释可以看List.impl.h里的注释。 <br>
9.list中，STL先写好了一个辅助函数transfer（书139页），然后让splice，merge，reverse和sort调用它，项目作者硬写了两个，merge和sort里则调用了与transfer功能相似的splice。为了编码风格统一，我采用STL的写法，先写一个transfer，然后统一调用。 <br>
10.list实现里最要留心的问题就是头指针的变化和list为空这两个情况，有时还会一起遇到。newNode和deleteNode只负责申请内存、构造、析构和释放内存，与list关系不大。处理头指针和list为空的代码都写进insert、erase和transfer里，其他代码要增删节点则只调用他们，这样可以把头指针和list为空的情况集中在这三个函数里处理。
